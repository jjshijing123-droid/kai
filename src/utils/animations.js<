/**
 * 动画工具库 - 提供各种实用的动画效果
 */

// 缓动函数
const EasingFunctions = {
  // 基础缓动
  linear: (t) => t,
  
  // 二次缓动
  easeInQuad: (t) => t * t,
  easeOutQuad: (t) => t * (2 - t),
  easeInOutQuad: (t) => (t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t),
  
  // 三次缓动
  easeInCubic: (t) => t * t * t,
  easeOutCubic: (t) => (--t) * t * t + 1,
  easeInOutCubic: (t) => (t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1),
  
  // 四次缓动
  easeInQuart: (t) => t * t * t * t,
  easeOutQuart: (t) => 1 - (--t) * t * t * t,
  easeInOutQuart: (t) => (t < 0.5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t),
  
  // 弹性缓动
  easeInElastic: (t) => {
    if (t === 0) return 0
    if (t === 1) return 1
    return -(Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1.1) * 5 * Math.PI))
  },
  easeOutElastic: (t) => {
    if (t === 0) return 0
    if (t === 1) return 1
    return Math.pow(2, -10 * t) * Math.sin((t - 0.1) * 10 * Math.PI) + 1
  },
  
  // 回弹缓动
  easeInBounce: (t) => 1 - EasingFunctions.easeOutBounce(1 - t),
  easeOutBounce: (t) => {
    if (t < (1 / 2.75)) {
      return 7.5625 * t * t
    } else if (t < (2 / 2.75)) {
      return 7.5625 * (t -= (1.5 / 2.75)) * t + 0.75
    } else if (t < (2.5 / 2.75)) {
      return 7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375
    } else {
      return 7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375
    }
  }
}

/**
 * 动画类 - 用于创建高性能的CSS动画
 */
class Animation {
  constructor(options = {}) {
    this.duration = options.duration || 1000
    this.easing = options.easing || 'easeInOutCubic'
    this.delay = options.delay || 0
    this.iterations = options.iterations || 1
    this.direction = options.direction || 'normal'
    this.fill = options.fill || 'forwards'
    
    this.startTime = null
    this.isPlaying = false
    this.isPaused = false
    this.currentTime = 0
    
    this.onStart = options.onStart || (() => {})
    this.onUpdate = options.onUpdate || (() => {})
    this.onComplete = options.onComplete || (() => {})
    this.onRepeat = options.onRepeat || (() => {})
  }
  
  // 开始动画
  play() {
    if (this.isPlaying) return this
    
    this.isPlaying = true
    this.isPaused = false
    
    if (this.startTime === null) {
      this.startTime = performance.now()
    } else {
      this.startTime = performance.now() - this.currentTime
    }
    
    this.onStart()
    this.tick()
    
    return this
  }
  
  // 暂停动画
  pause() {
    if (!this.isPlaying || this.isPaused) return this
    
    this.isPaused = true
    this.isPlaying = false
    
    return this
  }
  
  // 恢复动画
  resume() {
    if (!this.isPaused) return this
    
    this.isPaused = false
    this.isPlaying = true
    this.startTime = performance.now() - this.currentTime
    
    this.tick()
    
    return this
  }
  
  // 停止动画
  stop() {
    this.isPlaying = false
    this.isPaused = false
    this.startTime = null
    this.currentTime = 0
    
    return this
  }
  
  // 重新开始动画
  restart() {
    this.stop()
    this.play()
    
    return this
  }
  
  // 设置动画时间
  seek(time) {
    this.currentTime = Math.max(0, Math.min(time, this.duration))
    
    if (this.isPlaying) {
      this.onUpdate(this.getProgress())
    }
    
    return this
  }
  
  // 获取当前进度 (0-1)
  getProgress() {
    return this.currentTime / this.duration
  }
  
  // 动画循环
  tick() {
    if (!this.isPlaying || this.isPaused) return
    
    const now = performance.now()
    this.currentTime = now - this.startTime - this.delay
    
    if (this.currentTime < 0) {
      requestAnimationFrame(() => this.tick())
      return
    }
    
    const progress = Math.min(this.currentTime / this.duration, 1)
    const easedProgress = EasingFunctions[this.easing](progress)
    
    this.onUpdate(easedProgress)
    
    if (progress >= 1) {
      if (this.iterations === 'infinite' || this.iterations > 1) {
        if (this.iterations !== 'infinite') {
          this.iterations--
        }
        
        this.currentTime = 0
        this.startTime = performance.now()
        this.onRepeat()
        
        if (this.isPlaying) {
          requestAnimationFrame(() => this.tick())
        }
      } else {
        this.isPlaying = false
        this.onComplete()
      }
    } else {
      requestAnimationFrame(() => this.tick())
    }
  }
}

/**
 * 便捷的动画创建函数
 */
export function createAnimation(options = {}) {
  return new Animation(options)
}

/**
 * 元素动画工厂函数
 */
export function animateElement(element, properties, options = {}) {
  return new Promise((resolve) => {
    const animation = new Animation({
      ...options,
      onUpdate: (progress) => {
        // 应用属性插值
        Object.keys(properties).forEach(property => {
          const startValue = parseFloat(getComputedStyle(element)[property]) || 0
          const endValue = properties[property]
          const currentValue = startValue + (endValue - startValue) * progress
          
          element.style[property] = `${currentValue}${getPropertyUnit(property)}`
        })
        
        if (options.onUpdate) {
          options.onUpdate(progress)
        }
      },
      onComplete: () => {
        // 确保最终值设置正确
        Object.keys(properties).forEach(property => {
          element.style[property] = `${properties[property]}${getPropertyUnit(property)}`
        })
        
        resolve()
      }
    })
    
    animation.play()
  })
}

/**
 * 获取CSS属性的单位
 */
function getPropertyUnit(property) {
  const unitlessProperties = [
    'opacity', 'zIndex', 'fontWeight', 'lineHeight',
    'flexGrow', 'flexShrink', 'flexBasis', 'order',
    'tabIndex', 'fillOpacity', 'strokeOpacity'
  ]
  
  return unitlessProperties.includes(property) ? '' : 'px'
}

/**
 * 预定义的动画效果
 */
export const PresetAnimations = {
  // 淡入淡出
  fadeIn: (element, options = {}) => {
    return animateElement(element, { opacity: 1 }, {
      duration: 300,
      easing: 'easeOutQuad',
      ...options
    })
  },
  
  fadeOut: (element, options = {}) => {
    return animateElement(element, { opacity: 0 }, {
      duration: 300,
      easing: 'easeInQuad',
      ...options
    })
  },
  
  // 滑入滑出
  slideIn: (element, direction = 'right', options = {}) => {
    const transforms = {
      right: { transform: 'translateX(0)' },
      left: { transform: 'translateX(0)' },
      up: { transform: 'translateY(0)' },
      down: { transform: 'translateY(0)' }
    }
    
    const startTransforms = {
      right: { transform: 'translateX(100%)' },
      left: { transform: 'translateX(-100%)' },
      up: { transform: 'translateY(-100%)' },
      down: { transform: 'translateY(100%)' }
    }
    
    // 设置初始位置
    Object.assign(element.style, startTransforms[direction])
    
    return animateElement(element, transforms[direction], {
      duration: 400,
      easing: 'easeOutCubic',
      ...options
    })
  },
  
  slideOut: (element, direction = 'right', options = {}) => {
    const transforms = {
      right: { transform: 'translateX(100%)' },
      left: { transform: 'translateX(-100%)' },
      up: { transform: 'translateY(-100%)' },
      down: { transform: 'translateY(100%)' }
    }
    
    return animateElement(element, transforms[direction], {
      duration: 300,
      easing: 'easeInCubic',
      ...options
    })
  },
  
  // 缩放动画
  scaleIn: (element, options = {}) => {
    element.style.transformOrigin = 'center'
    return animateElement(element, { transform: 'scale(1)' }, {
      duration: 300,
      easing: 'easeOutElastic',
      ...options
    })
  },
  
  scaleOut: (element, options = {}) => {
    return animateElement(element, { transform: 'scale(0)' }, {
      duration: 200,
      easing: 'easeInQuad',
      ...options
    })
  },
  
  // 旋转动画
  rotateIn: (element, options = {}) => {
    element.style.transformOrigin = 'center'
    return animateElement(element, { transform: 'rotate(0deg)' }, {
      duration: 500,
      easing: 'easeOutCubic',
      ...options
    })
  },
  
  // 弹跳动画
  bounce: (element, options = {}) => {
    const keyframes = [
      { transform: 'translateY(0)' },
      { transform: 'translateY(-20px)' },
      { transform: 'translateY(0)' },
      { transform: 'translateY(-10px)' },
      { transform: 'translateY(0)' }
    ]
    
    return animateKeyframes(element, keyframes, {
      duration: 600,
      easing: 'easeOutBounce',
      ...options
    })
  },
  
  // 震动动画
  shake: (element, options = {}) => {
    const keyframes = [
      { transform: 'translateX(0)' },
      { transform: 'translateX(-5px)' },
      { transform: 'translateX(5px)' },
      { transform: 'translateX(-3px)' },
      { transform: 'translateX(3px)' },
      { transform: 'translateX(0)' }
    ]
    
    return animateKeyframes(element, keyframes, {
      duration: 500,
      easing: 'easeInOutQuad',
      ...options
    })
  },
  
  // 脉冲动画
  pulse: (element, options = {}) => {
    const keyframes = [
      { transform: 'scale(1)' },
      { transform: 'scale(1.05)' },
      { transform: 'scale(1)' }
    ]
    
    return animateKeyframes(element, keyframes, {
      duration: 1000,
      iterations: 'infinite',
      ...options
    })
  }
}

/**
 * 关键帧动画
 */
export function animateKeyframes(element, keyframes, options = {}) {
  return new Promise((resolve) => {
    const totalDuration = options.duration || 1000
    const keyframeCount = keyframes.length
    const frameDuration = totalDuration / (keyframeCount - 1)
    
    const animation = new Animation({
      ...options,
      onUpdate: (progress) => {
        const frameIndex = Math.floor(progress * (keyframeCount - 1))
        const nextFrameIndex = Math.min(frameIndex + 1, keyframeCount - 1)
        const frameProgress = (progress * (keyframeCount - 1)) - frameIndex
        
        // 插值计算
        const currentFrame = keyframes[frameIndex]
        const nextFrame = keyframes[nextFrameIndex]
        
        Object.keys(currentFrame).forEach(property => {
          const startValue = parseFloat(currentFrame[property]) || 0
          const endValue = parseFloat(nextFrame[property]) || 0
          const currentValue = startValue + (endValue - startValue) * frameProgress
          
          element.style[property] = `${currentValue}${getPropertyUnit(property)}`
        })
      },
      onComplete: resolve
    })
    
    animation.play()
  })
}

/**
 * 页面转场动画
 */
export const PageTransitions = {
  // 滑动转场
  slide: (container, direction = 'left', options = {}) => {
    const transforms = {
      left: { transform: 'translateX(0)' },
      right: { transform: 'translateX(0)' },
      up: { transform: 'translateY(0)' },
      down: { transform: 'translateY(0)' }
    }
    
    const startTransforms = {
      left: { transform: 'translateX(100%)' },
      right: { transform: 'translateX(-100%)' },
      up: { transform: 'translateY(100%)' },
      down: { transform: 'translateY(-100%)' }
    }
    
    // 设置初始位置
    Object.assign(container.style, startTransforms[direction])
    
    return animateElement(container, transforms[direction], {
      duration: 400,
      easing: 'easeInOutCubic',
      ...options
    })
  },
  
  // 淡入淡出转场
  fade: (container, options = {}) => {
    return animateElement(container, { opacity: 1 }, {
      duration: 300,
      easing: 'easeInOutQuad',
      ...options
    })
  },
  
  // 缩放转场
  scale: (container, options = {}) => {
    container.style.transformOrigin = 'center'
    return animateElement(container, { transform: 'scale(1)' }, {
      duration: 350,
      easing: 'easeOutCubic',
      ...options
    })
  }
}

/**
 * 工具函数
 */

// 防抖函数
export function debounce(func, wait) {
  let timeout
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout)
      func(...args)
    }
    clearTimeout(timeout)
    timeout = setTimeout(later, wait)
  }
}

// 节流函数
export function throttle(func, limit) {
  let inThrottle
  return function() {
    const args = arguments
    const context = this
    if (!inThrottle) {
      func.apply(context, args)
      inThrottle = true
      setTimeout(() => inThrottle = false, limit)
    }
  }
}

// 等待函数
export function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms))
}

// 检测元素是否在视窗中
export function isElementInViewport(element) {
  const rect = element.getBoundingClientRect()
  return (
    rect.top >= 0 &&
    rect.left >= 0 &&
    rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
    rect.right <= (window.innerWidth || document.documentElement.clientWidth)
  )
}

export default {
  Animation,
  createAnimation,
  animateElement,
  PresetAnimations,
  animateKeyframes,
  PageTransitions,
  EasingFunctions,
  debounce,
  throttle,
  sleep,
  isElementInViewport
}