/**
 * 组件测试工具库
 * 为Vue组件提供统一的测试基础架构
 */

import { mount, shallowMount, createLocalVue } from '@vue/test-utils'
import { createVuetify } from 'vuetify'

// 创建测试用的Vuetify实例
const vuetify = createVuetify()

/**
 * 创建测试环境
 */
export function createTestSetup(options = {}) {
  const localVue = createLocalVue()
  
  const config = {
    localVue,
    vuetify,
    stubs: {
      RouterLink: true,
      RouterView: true,
      ...options.stubs
    },
    mocks: {
      $t: (key) => key,
      $i18n: { locale: 'zh-CN' },
      ...options.mocks
    },
    methods: {
      ...options.methods
    },
    propsData: {
      ...options.propsData
    },
    data() {
      return {
        ...options.data
      }
    },
    computed: {
      ...options.computed
    },
    ...options.config
  }
  
  return {
    mount: (component, options = {}) => mount(component, { ...config, ...options }),
    shallowMount: (component, options = {}) => shallowMount(component, { ...config, ...options })
  }
}

/**
 * 模拟数据生成器
 */
export function createMockData() {
  return {
    // 产品数据
    products: Array.from({ length: 10 }, (_, i) => ({
      id: i + 1,
      name: `产品 ${i + 1}`,
      description: `产品 ${i + 1} 的描述`,
      price: Math.floor(Math.random() * 1000) + 100,
      category: ['电子产品', '服装', '食品', '图书'][i % 4],
      status: 'active',
      createdAt: new Date().toISOString(),
      images: [`image-${i + 1}.jpg`],
      tags: [`tag-${i + 1}`, `tag-${i + 2}`],
      stock: Math.floor(Math.random() * 100),
      rating: Math.floor(Math.random() * 5) + 1
    })),
    
    // 错误数据
    errors: [
      {
        id: 'err-1',
        type: 'NETWORK_ERROR',
        message: '网络连接失败',
        severity: 'high',
        timestamp: new Date().toISOString(),
        details: { url: '/api/products' }
      },
      {
        id: 'err-2',
        type: 'VALIDATION_ERROR',
        message: '输入验证失败',
        severity: 'medium',
        timestamp: new Date().toISOString(),
        details: { field: 'email' }
      }
    ],
    
    // 通知数据
    notifications: [
      {
        id: 1,
        type: 'success',
        title: '操作成功',
        message: '产品保存成功',
        duration: 3000
      },
      {
        id: 2,
        type: 'error',
        title: '操作失败',
        message: '网络连接错误',
        duration: 5000
      }
    ],
    
    // 文件数据
    files: Array.from({ length: 5 }, (_, i) => ({
      id: i + 1,
      name: `文件-${i + 1}.pdf`,
      size: Math.floor(Math.random() * 1024 * 1024) + 1024,
      type: 'application/pdf',
      uploadedAt: new Date().toISOString(),
      url: `/uploads/file-${i + 1}.pdf`
    }))
  }
}

/**
 * 组件测试通用方法
 */
export class ComponentTestHelper {
  constructor(component, options = {}) {
    this.component = component
    this.setup = createTestSetup(options)
  }
  
  // 挂载组件
  mount(props = {}, options = {}) {
    this.wrapper = this.setup.mount(this.component, {
      propsData: props,
      ...options
    })
    return this.wrapper
  }
  
  // 浅挂载组件
  shallowMount(props = {}, options = {}) {
    this.wrapper = this.setup.shallowMount(this.component, {
      propsData: props,
      ...options
    })
    return this.wrapper
  }
  
  // 查找元素
  find(selector) {
    return this.wrapper.find(selector)
  }
  
  // 查找所有元素
  findAll(selector) {
    return this.wrapper.findAll(selector)
  }
  
  // 触发事件
  trigger(event, selector = null) {
    const element = selector ? this.find(selector) : this.wrapper
    element.trigger(event)
  }
  
  // 设置响应式数据
  setData(data) {
    this.wrapper.setData(data)
  }
  
  // 设置Props
  setProps(props) {
    this.wrapper.setProps(props)
  }
  
  // 等待异步操作
  async nextTick() {
    await this.wrapper.vm.$nextTick()
  }
  
  // 等待定时器
  async wait(ms) {
    return new Promise(resolve => setTimeout(resolve, ms))
  }
  
  // 检查元素存在
  expectToExist(selector) {
    expect(this.find(selector).exists()).toBe(true)
  }
  
  // 检查元素不存在
  expectNotToExist(selector) {
    expect(this.find(selector).exists()).toBe(false)
  }
  
  // 检查元素文本
  expectText(selector, text) {
    expect(this.find(selector).text()).toBe(text)
  }
  
  // 检查元素包含文本
  expectContainText(selector, text) {
    expect(this.find(selector).text()).toContain(text)
  }
  
  // 检查属性值
  expectAttribute(selector, attribute, value) {
    expect(this.find(selector).attributes(attribute)).toBe(value)
  }
  
  // 检查类名
  expectClass(selector, className) {
    expect(this.find(selector).classes()).toContain(className)
  }
  
  // 清理
  destroy() {
    if (this.wrapper) {
      this.wrapper.destroy()
    }
  }
}

/**
 * API测试工具
 */
export class APITestHelper {
  constructor(baseURL = '/api') {
    this.baseURL = baseURL
    this.mockData = createMockData()
  }
  
  // Mock fetch
  setupMockFetch() {
    global.fetch = jest.fn().mockImplementation(this.mockFetch.bind(this))
  }
  
  // Mock实现
  async mockFetch(url, options = {}) {
    const method = options.method || 'GET'
    const response = {
      ok: true,
      status: 200,
      headers: new Map([['content-type', 'application/json']]),
      json: async () => ({ success: true }),
      text: async () => 'success'
    }
    
    try {
      // 产品API
      if (url.startsWith('/api/products')) {
        return this.handleProductsRequest(url, method, options, response)
      }
      
      // 文件API
      if (url.startsWith('/api/files')) {
        return this.handleFilesRequest(url, method, options, response)
      }
      
      // 错误API
      if (url.startsWith('/api/errors')) {
        return this.handleErrorsRequest(url, method, options, response)
      }
      
      // 健康检查API
      if (url === '/api/health') {
        return { ...response, json: async () => ({ status: 'ok' }) }
      }
      
      return response
    } catch (error) {
      return {
        ok: false,
        status: 500,
        json: async () => ({ error: error.message })
      }
    }
  }
  
  // 处理产品请求
  handleProductsRequest(url, method, options, response) {
    const id = url.split('/').pop()
    
    if (method === 'GET') {
      if (id && id !== 'products') {
        // 获取单个产品
        const product = this.mockData.products.find(p => p.id == id)
        if (product) {
          return { ...response, json: async () => product }
        } else {
          return {
            ok: false,
            status: 404,
            json: async () => ({ error: 'Product not found' })
          }
        }
      } else {
        // 获取产品列表
        return { ...response, json: async () => this.mockData.products }
      }
    }
    
    if (method === 'POST' || method === 'PUT') {
      return { ...response, json: async () => ({ id: Date.now(), ...options.body }) }
    }
    
    if (method === 'DELETE') {
      return { ...response, json: async () => ({ success: true }) }
    }
    
    return response
  }
  
  // 处理文件请求
  handleFilesRequest(url, method, options, response) {
    if (method === 'GET') {
      return { ...response, json: async () => this.mockData.files }
    }
    
    if (method === 'POST') {
      return {
        ...response,
        json: async () => ({
          id: Date.now(),
          name: options.body?.name || 'uploaded-file.pdf',
          url: '/uploads/uploaded-file.pdf'
        })
      }
    }
    
    return response
  }
  
  // 处理错误请求
  handleErrorsRequest(url, method, options, response) {
    if (method === 'POST') {
      return { ...response, json: async () => ({ success: true, id: Date.now() }) }
    }
    
    return response
  }
  
  // 清理Mock
  cleanup() {
    if (global.fetch) {
      global.fetch.mockRestore()
    }
  }
}

/**
 * 通用测试用例模板
 */
export function createCommonTests(componentName, tests = {}) {
  return {
    [`${componentName} 组件存在`]: () => {
      expect(typeof componentName).toBe('object')
    },
    
    [`${componentName} 可以正常挂载`]: () => {
      const helper = new ComponentTestHelper(componentName)
      const wrapper = helper.mount()
      expect(wrapper.exists()).toBe(true)
      helper.destroy()
    },
    
    ...tests
  }
}

/**
 * 性能测试工具
 */
export class PerformanceTester {
  constructor() {
    this.measurements = []
  }
  
  // 测量函数执行时间
  async measure(name, fn) {
    const start = performance.now()
    const result = await fn()
    const end = performance.now()
    const duration = end - start
    
    this.measurements.push({ name, duration, timestamp: Date.now() })
    
    return { result, duration }
  }
  
  // 多次测量平均值
  async measureAverage(name, fn, times = 10) {
    const measurements = []
    
    for (let i = 0; i < times; i++) {
      const { duration } = await this.measure(`${name}-${i}`, fn)
      measurements.push(duration)
    }
    
    const average = measurements.reduce((a, b) => a + b, 0) / measurements.length
    const min = Math.min(...measurements)
    const max = Math.max(...measurements)
    
    return { average, min, max, measurements }
  }
  
  // 获取测量结果
  getMeasurements() {
    return this.measurements
  }
  
  // 清理测量数据
  clear() {
    this.measurements = []
  }
}

/**
 * 内存测试工具
 */
export class MemoryTester {
  constructor() {
    this.snapshots = []
  }
  
  // 拍摄内存快照
  takeSnapshot(name) {
    if (global.performance && global.performance.memory) {
      this.snapshots.push({
        name,
        timestamp: Date.now(),
        used: global.performance.memory.usedJSHeapSize,
        total: global.performance.memory.totalJSHeapSize,
        limit: global.performance.memory.jsHeapSizeLimit
      })
    }
  }
  
  // 检查内存增长
  checkMemoryGrowth(threshold = 10) { // MB
    if (this.snapshots.length < 2) return false
    
    const last = this.snapshots[this.snapshots.length - 1]
    const previous = this.snapshots[this.snapshots.length - 2]
    
    const growth = (last.used - previous.used) / 1024 / 1024
    return growth > threshold
  }
  
  // 获取快照
  getSnapshots() {
    return this.snapshots
  }
}

/**
 * 可访问性测试工具
 */
export class AccessibilityTester {
  constructor(wrapper) {
    this.wrapper = wrapper
  }
  
  // 检查元素是否可聚焦
  isFocusable(selector) {
    const element = this.wrapper.find(selector)
    return element.attributes('tabindex') !== undefined || 
           ['button', 'input', 'select', 'textarea', 'a'].includes(element.tagName())
  }
  
  // 检查是否有aria-label
  hasAriaLabel(selector) {
    const element = this.wrapper.find(selector)
    return element.attributes('aria-label') !== undefined
  }
  
  // 检查是否有role属性
  hasRole(selector) {
    const element = this.wrapper.find(selector)
    return element.attributes('role') !== undefined
  }
  
  // 检查键盘可访问性
  checkKeyboardAccessibility() {
    const focusableElements = this.wrapper.findAll('[tabindex], button, input, select, textarea, a')
    return focusableElements.length > 0
  }
  
  // 运行可访问性检查
  runAccessibilityCheck() {
    const results = {
      focusableElements: this.wrapper.findAll('[tabindex], button, input, select, textarea, a').length,
      ariaLabels: this.wrapper.findAll('[aria-label]').length,
      roles: this.wrapper.findAll('[role]').length
    }
    
    return results
  }
}

// 默认导出
export default {
  createTestSetup,
  createMockData,
  ComponentTestHelper,
  APITestHelper,
  createCommonTests,
  PerformanceTester,
  MemoryTester,
  AccessibilityTester
}